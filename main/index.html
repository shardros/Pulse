<!DOCTYPE html>
<html>
<head>

  <link type="text/css" rel="stylesheet" href="styles/index.css"/>

</head>
<body>

<h1>Edwin's autorouter</h1>

<div id="grid">

</div>

<!--Work out why this needs a container-->
<div class="endPoint" id="startnode">
  <div class="endPointPadder" id="startnodePadding"></div>
</div>

<div class="endPoint" id="endnode">
  <div class="endPointPadder" id="endnodePadding"></div>
</div>



<script>
  //Make the DIV element draggagle:
  dragElement(document.getElementById("startnode"));
  dragElement(document.getElementById("endnode"),200,200);

  function dragElement(elmnt, startx = 100, starty = 100) {
    var newXPos = 0, newYPos = 0,
        oldXPos = 0, oldYPos = 0;
      document.getElementById(elmnt.id + "Padding").onmousedown = dragMouseDown;
      elmnt.style.top = (starty) + "px";
      elmnt.style.left = (startx) + "px";

    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();   //Prevents the default method from running

      // get the mouse cursor position at startup:
      oldXPos = getRoundedMouseX(e);
      oldYPos = getRoundedMouseY(e);

      document.onmouseup = closeDragElement;  //Assign the on mouseup method to closeDragElement

      document.onmousemove = elementDrag;     //Assign the on mousemove elementDrag method to elementDrag
    }

    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
    
      // calculate the new cursor position:
      newXPos = oldXPos - getRoundedMouseX(e);
      newYPos = oldYPos - getRoundedMouseY(e);
      
      // set the element's new position:
      elmnt.style.top = (elmnt.offsetTop - newYPos) + "px";
      elmnt.style.left = (elmnt.offsetLeft - newXPos) + "px";
    
      //Update the old positions
      oldXPos = getRoundedMouseX(e);
      oldYPos = getRoundedMouseY(e);
  }

    function closeDragElement() {
      /* stop moving when mouse button is released:*/
      document.onmouseup = null;
      document.onmousemove = null;
    }

    function getRoundedMouseX (event, roundToNearest = 25) {
        return Math.ceil(event.clientX / roundToNearest) * roundToNearest;
    }

    function getRoundedMouseY (event, roundToNearest = 25) {
        return Math.ceil(event.clientY / roundToNearest) * roundToNearest;
    }
  }

class clientSideNet {
  /**
  * @pram {html} startNode
  * @pram {html} endNode
  */
  constructor (startNode, endNode) {
    this.startNode = startNode;
    this.endNode = endNode;
  }
}

class grid {
  constructor (width, height, cellSize) {
    this.width = width;
    this.height = height;
    this.cellSize = cellSize;
    this.netList = [];    
  }

  addNet(net) {
    this.netList.push(net)
  }

  update() {
    fetch('route?test="test"')
  }
}

let test = new grid(10,10,10);
test.update();
</script>

</body>
</html>
