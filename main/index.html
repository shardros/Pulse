<!DOCTYPE html>
<html>
<head>

  <link type="text/css" rel="stylesheet" href="styles/index.css"/>
  <meta charset="utf-8"/>
</head>
<body>

  
<div class="grid-container">
  
  <div class="title">
    <h1>Edwin's autorouter</h1>
  </div>

  <div class="control-pannel">
    <h2>Control-pannel</h2>
  </div>

  <div id="board">

  </div>

  <!--Work out why this needs a container-->
  <div class="startPoint" id="start1node">
    <div class="startPointPadder" id="start1nodePadding"></div>
  </div>

  <div class="endPoint" id="end1node">
    <div class="endPointPadder" id="end1nodePadding"></div>
  </div>

  <!--Work out why this needs a container-->
  <div class="startPoint" id="start2node">
    <div class="startPointPadder" id="start2nodePadding"></div>
  </div>

  <div class="endPoint" id="end2node">
    <div class="endPointPadder" id="end2nodePadding"></div>
  </div>
</div>

<script>
//Define some functions for use just here 
//Does cellsize work up here?
function getRoundedMouseX (event, roundToNearest = cellSize) {
  return Math.ceil(event.clientX / roundToNearest) * roundToNearest;
}

function getRoundedMouseY (event, roundToNearest = cellSize) {
  return Math.ceil(event.clientY / roundToNearest) * roundToNearest;
}

//Make this just a data strucuture
class clientSideCell {
  constructor(x,y,elementID){
    this.x = x;
    this.y = y; 
    this.elementID = elementID;
    this.el = document.getElementById(elementID);
  }
}

//Make this just a data strucuture
class clientSideNet {
  constructor(start, end, id) {
    this.start = start;
    this.end = end;
    this.id = id;
  }
}

class Grid {
  /**
  @pram {Number} width the width cell units
  @pram {Number} width the height in cell units
  @pram {Number} cellSize the size in cell units
  */
  constructor (gridID, width, height, cellSize) {
    this.grid = document.getElementById(gridID);
    this.width = width;
    this.height = height;
    this.cellSize = cellSize;
    this.netList = [];    
  }

   makeDragable(cell) {
    console.log(cell)
    var grid = this;

    var startx = cell.x * this.cellSize;
    var starty = cell.y * this.cellSize;
    var newXPos = 0, newYPos = 0,
      oldXPos = 0, oldYPos = 0;
    var elmnt = cell.el; //el is standard shorthand for element in web frameoworks

    document.getElementById(cell.elementID + "Padding").onmousedown = dragMouseDown;
    elmnt.style.top = (starty) + 37 + "px";
    elmnt.style.left = (startx) + "px";

    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();   //Prevents the default method from running

      // get the mouse cursor position at startup:
      oldXPos = getRoundedMouseX(e);
      oldYPos = getRoundedMouseY(e);

      document.onmouseup = closeDragElement;  //Assign the on mouseup method to closeDragElement

      document.onmousemove = elementDrag;     //Assign the on mousemove elementDrag method to elementDrag
    }

    function elementDrag(e) {
      e = e || window.event; //Work out what this does
      e.preventDefault();
    
      // calculate the new cursor position:
      newXPos = oldXPos - getRoundedMouseX(e);
      newYPos = oldYPos - getRoundedMouseY(e);
        
      // set the element's new position:
      elmnt.style.top = (elmnt.offsetTop - newYPos) + "px";
      elmnt.style.left = (elmnt.offsetLeft - newXPos) + "px";
    
      //Update the old positions
      oldXPos = getRoundedMouseX(e);
      oldYPos = getRoundedMouseY(e);
    }

    function closeDragElement() {
      /* stop moving when mouse button is released:*/
      document.onmouseup = null;
      document.onmousemove = null;

      //update the cells position.
      cell.x = Math.ceil(elmnt.offsetLeft/grid.cellSize);
      cell.y = Math.ceil(elmnt.offsetTop/grid.cellSize) - 4;

      grid.update();
    }
  }

  /**
   * Inalizes a net
   */
  createNet(startx,starty,startEl,endx,endy,endEl) {
    let start = new clientSideCell(startx, starty, startEl);
    let end = new clientSideCell(endx, endy, endEl);
    
    this.makeDragable(start);
    this.makeDragable(end);

    let net = new clientSideNet(start,end,this.netList.length);
    
    this.netList.push(net);
  }
  
  addNet(net) {
    this.netList.push(net)
    return this.netList.length - 1;
  }

  //This is quite hacky and not very OOP should fix at somepoint
  net(id, contents) {
    this.netList[id] = contents; 
  }

  async update() {
    //Fetch the SVG DOM from the server but store the value as a promise
    let resGrid = fetch('/route?cellSize=' + this.cellSize, {
    
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(this.netList)
    
    })
    
    //Await for the promise to be fullied when it is set the value of the dom to be that
    this.grid.innerHTML = await resGrid.then(response => response.text());
  }
}


//------------MAIN------------

const cellSize = 10;
const gridWidth = 10;
const gridHeight = 10;
const gridID = "board";

const startE1 = "start1node";
const endE1 = "end1node";

const startE2 = "start2node";
const endE2 = "end2node";

var grid = new Grid(gridID,gridWidth,gridHeight,cellSize);

grid.createNet(2,2,startE1,3,8,endE1)
grid.createNet(8,8,startE2,10,10,endE2)

grid.update();

</script>

</body>
</html>
