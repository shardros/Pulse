<!DOCTYPE html>
<html>
<head>

  <link type="text/css" rel="stylesheet" href="styles/index.css"/>

</head>
<body>

<h1>Edwin's autorouter</h1>

<div id="grid">

</div>

<!--Work out why this needs a container-->
<div class="endPoint" id="startnode">
  <div class="endPointPadder" id="startnodePadding"></div>
</div>

<div class="endPoint" id="endnode">
  <div class="endPointPadder" id="endnodePadding"></div>
</div>



<script>
//Define some classes for use just here 

clientSideCell = function(x,y){
  this.x = x;
  this.y = y;
}

clientSideNet = function(start, end) {
  this.start = start;
  this.end = end;
}

class Grid {
  /**
  @pram {Number} width the width cell units
  @pram {Number} width the height in cell units
  @pram {Number} cellSize the size in cell units
  */
  constructor (gridID, width, height, cellSize) {
    this.grid = document.getElementById(gridID);
    this.width = width;
    this.height = height;
    this.cellSize = cellSize;
    this.netList = [];    
  }

  addNet(net) {
    this.netList.push(net)
    return this.netList.length - 1;
  }

  //This is quite hacky and not very OOP should fix at somepoint
  net(id, contents) {
    this.netList[id] = contents; 
  }

  async update() {
    //Fetch the SVG DOM from the server but store the value as a promise
    let resGrid = fetch('/route?cellSize=' + this.cellSize, {
    
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(this.netList)
    
    })
    
    //Await for the promise to be fullied when it is set the value of the dom to be that
    this.grid.innerHTML = await resGrid.then(response => response.text());
  }
}


//------------MAIN------------

const cellSize = 10;
const gridWidth = 10;
const gridHeight = 10;
const gridID = "grid";

let start = new clientSideCell(2,2);
let end = new clientSideCell(4,4);
let net = new clientSideNet(start,end);

var grid = new Grid(gridID,gridWidth,gridHeight,cellSize);

grid.addNet(net);

net.start.x = 10;
net.start.y = 10;

grid.net(0, net);

grid.update();

//Make the DIV element draggagle:

dragElement(document.getElementById("startnode"));
dragElement(document.getElementById("endnode"),200,200);

function dragElement(elmnt, startx = 100, starty = 100) {
  var newXPos = 0, newYPos = 0,
      oldXPos = 0, oldYPos = 0;
    document.getElementById(elmnt.id + "Padding").onmousedown = dragMouseDown;
    elmnt.style.top = (starty) + "px";
    elmnt.style.left = (startx) + "px";

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();   //Prevents the default method from running

    // get the mouse cursor position at startup:
    oldXPos = getRoundedMouseX(e);
    oldYPos = getRoundedMouseY(e);

    document.onmouseup = closeDragElement;  //Assign the on mouseup method to closeDragElement

    document.onmousemove = elementDrag;     //Assign the on mousemove elementDrag method to elementDrag
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
  
    // calculate the new cursor position:
    newXPos = oldXPos - getRoundedMouseX(e);
    newYPos = oldYPos - getRoundedMouseY(e);
    
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - newYPos) + "px";
    elmnt.style.left = (elmnt.offsetLeft - newXPos) + "px";
  
    //Update the old positions
    oldXPos = getRoundedMouseX(e);
    oldYPos = getRoundedMouseY(e);
}

  function closeDragElement() {
    /* stop moving when mouse button is released:*/
    document.onmouseup = null;
    document.onmousemove = null;
  }

  function getRoundedMouseX (event, roundToNearest = cellSize) {
      return Math.ceil(event.clientX / roundToNearest) * roundToNearest;
  }

  function getRoundedMouseY (event, roundToNearest = cellSize) {
      return Math.ceil(event.clientY / roundToNearest) * roundToNearest;
  }
}



</script>

</body>
</html>
